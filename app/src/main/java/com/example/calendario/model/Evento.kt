package com.example.calendario.model // Verifique se o nome do seu pacote est√° correto

import com.google.firebase.firestore.DocumentId

open class EventoCalendario(
    // Agora que o import est√° correto, o erro aqui some.
    @DocumentId
    var id: String? = null,
    var titulo: String = "",
    var data: Long = 0L,
    var tipo: String = "GERAL"
) {
    // O Firestore precisa de um construtor vazio para funcionar.
    // Ele usa este construtor para criar o objeto antes de preencher os campos.
    constructor() : this(null, "", 0L, "GERAL")

    open fun exibirDetalhes(): String {
        return "Evento Padr√£o: $titulo"
    }
}


data class EventoAniversario(
    val aniversariante: String = ""
) : EventoCalendario() { // A heran√ßa acontece aqui, nos dois pontos ':'

    // O bloco 'init' √© executado assim que um objeto 'EventoAniversario' √© criado.
    // √â o lugar perfeito para definir o tipo espec√≠fico.
    init {
        tipo = "ANIVERSARIO"
    }

    // Usamos 'override' para SOBRESCREVER a fun√ß√£o da classe Pai.
    // Agora, quando chamarmos 'exibirDetalhes()' em um EventoAniversario, este texto ser√° mostrado.
    override fun exibirDetalhes(): String {
        return "Hoje √© dia de festa! Anivers√°rio de $aniversariante! ü•≥"
    }
}

data class EventoReuniao(
    val local: String = "",
    val participantes: List<String> = emptyList() // Uma lista para guardar os nomes
) : EventoCalendario() {

    init {
        tipo = "REUNIAO"
    }

    // Novamente, sobrescrevemos a fun√ß√£o para dar detalhes espec√≠ficos de uma reuni√£o.
    override fun exibirDetalhes(): String {
        // 'joinToString' √© uma fun√ß√£o √∫til do Kotlin para formatar listas.
        val listaDeNomes = participantes.joinToString(separator = ", ")
        return "Reuni√£o em '$local'. Participantes: $listaDeNomes."
    }
}
